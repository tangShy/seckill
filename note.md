# 1.高并发优化分析
## 关于并发
>并发性上不去的原因是什么？
* 是因为当多个线程访问同一行数据时，产生了事务，因此产生写锁，每当一个获取了事务的线程把锁释放，另一个排队线程才能拿到写锁，事务执行时间越短，并发性越高，这也是要将费时的I/O操作移出事务的原因。

>项目中高并发发生的地方
* 详情页
* 获取系统时间
* 地址暴露接口
* 执行秒杀操作

>为什么需要单独获取系统时间？
* 这是为了秒杀系统的优化做铺垫。比如在秒杀还没开始的时候，用户大量刷新秒杀商品详情页面是很正常的操作，
这时候秒杀还未开启，大量的请求发生到服务器会造成不必要的负担。
* 我们将这个详情页放置到CDN中，这样用户在访问该页面时就不需要访问我们的服务器了，起到了降低服务器压力的作用。
而CDN中存储的是静态化的详情页和一些静态资源（css、js等），这样我们就拿不到系统的时间来进行秒杀时段的控制，
所以我们需要单独设计一个请求来获取服务器的系统时间。

>CDN 的理解
* CDN即内容分发网络，CDN的关键技术主要有内容存储和分发技术。
* 基本原理：CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，
由缓存服务器直接响应用户请求。

>获取系统时间不需要优化
* 因为Java访问一次内存（Cacheline）大约 10ns,1s=10亿ns，也就是如果不考虑GC，这个操作1s可以做1亿次。

>秒杀地址接口分析
* 无法使用CDN缓存，因为秒杀地址返回的数据是变化的，不适合放在CDN缓存；
* 适合服务端缓存：Redis等，1秒钟可以承受10万qps。多个Redis组成集群，可以到100万qps。所以后端缓存可以用业务系统控制。

>秒杀地址接口优化
* Redis——>MySQL

>秒杀操作优化分析
* 无法使用CDN缓存
* 后端换粗困难：库存问题
* 一行数据竞争：热点商品

大部分写的操作和核心操作无法使用CDN，也不可能在缓存中减库存。你在Redis缓存中减库存，那么用户也可能通过缓存来减库存，这样库存会不一致，所以要使用mysql的事务来保证一致性。<br>
比如一个热点商品所有人都在抢， 那么在同一时间对数据表的同一行数据进行大量的update set操作。<br>
行级锁在commit之后才释放，所以优化方向是减少行级锁的持有时间。

>如何判断update更新库存成功？
* 有两个条件：<br>
     1.update自身没报错；<br>
     2.客户端确认update影响记录数<br>
* 优化思路：
把客户端逻辑放到MySQL服务端，避免网络延迟和GC影响

>如何把客户端逻辑放到MySQL服务端
- 两种方案：<br>
1.定制SQL方案，在每次update后都会自动提交，但需要修改MySQL源码，成本很高，不是大公司（BAT等）不会使用此方法。<br>
2.使用存储过程：整个事务在MySQL端完成，用存储过程写业务逻辑，服务端负责调用。
  
>优化总结
* 前端控制：<br>
暴露接口，按钮防重复（点击一次按钮后就变成灰色，禁止重复点击按钮）
* 动静态数据分离：<br>
CDN缓存，后端缓存
* 事务竞争优化：<br>
减少事务行级锁的持有时间

# 2.Redis后端缓存优化编码
* 2.1 下载安装Redis
* 2.2 在pom.xml中配置Redis客户端（jedis）
* 2.3 在pom.xml中配置protostuff依赖
* 2.4 使用Redis优化地址暴露接口
* 2.5 测试

# 3.秒杀操作————并发优化
* 3.1 简单优化
用户的秒杀操作分为两步：减库存、插入购买明细，我们在这里进行简单的优化，就是将原本先update（减库存）再进行insert（插入购买明细）的步骤改成：先insert再update。
* 3.2 深度优化
* 3.2.1 写一个存储过程procedure，然后在MySQL控制台里执行它
* 3.2.2 修改源码以调用存储过程

> 存储过程优化总结
1.存储过程优化：减少事务行级锁持有的时间<br>
2.不要过度依赖存储过程，简单的逻辑依赖存储过程<br>
3.QPS:一个秒杀单6000/qps


  







 
